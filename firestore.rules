rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns a document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Books collection
    match /books/{bookId} {
      // Anyone authenticated can read available books
      allow read: if isAuthenticated() && resource.data.swapStatus == 'Available';
      
      // Users can read their own books regardless of status
      allow read: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
      
      // Users can create books (must be authenticated and set themselves as owner)
      allow create: if isAuthenticated() && 
                     request.resource.data.ownerId == request.auth.uid &&
                     request.resource.data.ownerEmail == request.auth.token.email;
      
      // Users can update their own books (full update)
      allow update: if isAuthenticated() && 
                     resource.data.ownerId == request.auth.uid &&
                     request.resource.data.ownerId == request.auth.uid;
      
      // Allow any authenticated user to update swapStatus to 'Pending' when creating a swap offer
      // This prevents others from requesting the same book while an offer is pending
      allow update: if isAuthenticated() &&
                     // Only allow updating swapStatus and swapOfferId fields
                     request.resource.data.diff(resource.data).affectedKeys().hasOnly(['swapStatus', 'swapOfferId', 'updatedAt']) &&
                     // Only allow setting status to 'Pending' (not changing ownership or other fields)
                     request.resource.data.swapStatus == 'Pending' &&
                     // Ensure ownerId doesn't change
                     request.resource.data.ownerId == resource.data.ownerId;
      
      // Users can delete their own books
      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
    }
    
    // Swap offers collection
    match /swapOffers/{offerId} {
      // Users can read offers where they are the sender or recipient
      allow read: if isAuthenticated() && 
                  (resource.data.fromUserId == request.auth.uid || 
                   resource.data.toUserId == request.auth.uid);
      
      // Users can create swap offers (must be authenticated and set themselves as sender)
      allow create: if isAuthenticated() && 
                     request.resource.data.fromUserId == request.auth.uid &&
                     request.resource.data.fromUserEmail == request.auth.token.email;
      
      // Recipients can update swap offers (accept/reject)
      allow update: if isAuthenticated() && 
                     resource.data.toUserId == request.auth.uid &&
                     request.resource.data.status in ['Pending', 'Accepted', 'Rejected'];
      
      // Users cannot delete swap offers (for data integrity)
      allow delete: if false;
    }
    
    // Chats collection
    match /chats/{chatId} {
      // Users can read/create chat metadata if they are part of the chat
      // Chat ID format: chat_userId1_userId2 (sorted)
      // Check if current user is one of the participants
      allow read, create: if isAuthenticated() && 
                          (request.auth.uid == chatId.split('_')[1] || 
                           request.auth.uid == chatId.split('_')[2]);
      
      // Messages subcollection
      match /messages/{messageId} {
        // Users can read messages if they are part of the chat
        allow read: if isAuthenticated() && 
                    (request.auth.uid == chatId.split('_')[1] || 
                     request.auth.uid == chatId.split('_')[2]);
        
        // Users can create messages (must be authenticated and set themselves as sender)
        // Verify receiver is the other participant in the chat
        allow create: if isAuthenticated() &&
                       (request.auth.uid == chatId.split('_')[1] || 
                        request.auth.uid == chatId.split('_')[2]) &&
                       request.resource.data.senderId == request.auth.uid &&
                       request.resource.data.senderEmail == request.auth.token.email &&
                       (request.resource.data.receiverId == chatId.split('_')[1] ||
                        request.resource.data.receiverId == chatId.split('_')[2]);
        
        // Users cannot update or delete messages (for data integrity)
        allow update: if false;
        allow delete: if false;
      }
    }
  }
}

